<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coordonn√©es cart√©siennes et polaires</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']]
            },
            startup: {
                pageReady: () => {
                    return MathJax.startup.defaultPageReady();
                }
            }
        };
    </script>
    <style>
        :root {
            --primary: #1a237e;
            --secondary: #0d47a1;
            --accent: #0277bd;
            --light-blue: #e3f2fd;
            --dark-blue: #0a2463;
            --text: #2c3e50;
            --light-gray: #f8f9fa;
            --border: #b0bec5;
            --success: #2e7d32;
            --grid-color: #e0e0e0;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Latin Modern Roman', 'TeX Gyre Termes', 'STIX Two Text', Georgia, serif;
            background-color: var(--light-blue);
            color: var(--text);
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            padding: 2rem 0;
            margin-bottom: 2rem;
            border-bottom: 3px solid var(--primary);
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .header h1 {
            font-size: 2.8rem;
            font-weight: 700;
            letter-spacing: -0.5px;
            margin-bottom: 0.5rem;
        }
        
        .header .subtitle {
            font-size: 1.2rem;
            color: var(--accent);
            font-style: italic;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }
        
        @media (min-width: 992px) {
            .container {
                flex-direction: row;
            }
        }
        
        .content-section {
            flex: 1;
            min-width: 0;
        }
        
        .visualization-section {
            flex: 1;
            min-width: 0;
        }
        
        .card {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.08);
            border-left: 4px solid var(--accent);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
        }
        
        .section-title {
            display: flex;
            align-items: center;
            margin-bottom: 1.2rem;
            color: var(--primary);
            font-size: 1.6rem;
            font-weight: 700;
        }
        
        .section-title .icon {
            margin-right: 10px;
            font-size: 1.8rem;
            color: var(--accent);
        }
        
        .theorem {
            background: var(--light-gray);
            border: 2px solid var(--border);
            border-radius: 6px;
            padding: 1.2rem;
            margin: 1.2rem 0;
            position: relative;
        }
        
        .theorem::before {
            content: 'üìò';
            position: absolute;
            left: -15px;
            top: -15px;
            background: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid var(--accent);
        }
        
        .theorem-title {
            color: var(--primary);
            font-weight: 700;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .formula {
            font-family: 'Latin Modern Math', 'STIX Two Math', Cambria, serif;
            background: #f5f7ff;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
            border-left: 3px solid var(--success);
            overflow-x: auto;
        }
        
        .formula .math {
            font-size: 1.1rem;
        }
        
        .visualization-container {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.08);
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        
        .visualization-title {
            text-align: center;
            color: var(--primary);
            margin-bottom: 1.5rem;
            font-size: 1.4rem;
            font-weight: 700;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--light-blue);
        }
        
        #svg-container {
            width: 100%;
            height: 450px;
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
            background: #fafcff;
        }
        
        .coordinate-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
            padding: 1rem;
            background: linear-gradient(135deg, #e3f2fd, #f0f7ff);
            border-radius: 6px;
        }
        
        .coord-group {
            text-align: center;
        }
        
        .coord-label {
            font-size: 0.9rem;
            color: var(--primary);
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .coord-value {
            font-size: 1.2rem;
            font-family: 'Latin Modern Math', monospace;
            color: var(--dark-blue);
            font-weight: 700;
        }
        
        .instructions {
            text-align: center;
            margin-top: 1rem;
            padding: 0.8rem;
            background: var(--light-blue);
            border-radius: 6px;
            font-size: 0.9rem;
            color: var(--dark-blue);
        }
        
        .instructions i {
            color: var(--accent);
        }
        
        .calculator-section {
            margin-top: 2rem;
            padding: 1.5rem;
            background: linear-gradient(135deg, #e8f5e9, #f1f8e9);
            border-radius: 8px;
            border: 2px solid #4caf50;
        }
        
        .calculator-title {
            color: #2e7d32;
            font-size: 1.3rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .calculator-steps {
            background: white;
            padding: 1.2rem;
            border-radius: 6px;
            margin-top: 1rem;
            border-left: 3px solid #4caf50;
        }
        
        .calculator-steps ol {
            margin-left: 1.5rem;
        }
        
        .calculator-steps li {
            margin-bottom: 0.8rem;
            line-height: 1.8;
        }
        
        .key {
            display: inline-block;
            padding: 2px 8px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            font-weight: bold;
            margin: 0 2px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        .key-sequence {
            background: #f0f7ff;
            padding: 8px 12px;
            border-radius: 4px;
            margin: 5px 0;
            border-left: 3px solid #0277bd;
            font-family: monospace;
        }
        
        .video-section {
            margin-top: 2rem;
            padding: 1.5rem;
            background: linear-gradient(135deg, #fff3e0, #ffecb3);
            border-radius: 8px;
            border: 2px solid #ff9800;
            text-align: center;
        }
        
        .video-title {
            color: #ef6c00;
            font-size: 1.3rem;
            margin-bottom: 1rem;
        }
        
        .video-link {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 12px 24px;
            background: #ff9800;
            color: white;
            text-decoration: none;
            border-radius: 6px;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-top: 1rem;
        }
        
        .video-link:hover {
            background: #f57c00;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .note {
            background: #fff8e1;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            border-left: 3px solid #ffb300;
            font-size: 0.9em;
        }
        
        .angle-unit-info {
            background: #e8f5e9;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            border-left: 3px solid #4caf50;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .card {
                padding: 1rem;
            }
            
            .section-title {
                font-size: 1.4rem;
            }
            
            .visualization-container {
                position: static;
            }
            
            #svg-container {
                height: 350px;
            }
            
            .coordinate-display {
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 480px) {
            #svg-container {
                height: 300px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .coord-value {
                font-size: 1rem;
            }
        }
        
        /* Styles pour le SVG */
        .grid-line {
            stroke: var(--grid-color);
            stroke-width: 0.5;
        }
        
        .axis {
            stroke: var(--dark-blue);
            stroke-width: 1.5;
        }
        
        .axis-label {
            fill: var(--primary);
            font-size: 16px;
            font-weight: 600;
        }
        
        .vector {
            stroke: var(--accent);
            stroke-width: 1.5;
        }
        
        .vector-label {
            fill: var(--accent);
            font-size: 13px;
            font-weight: 600;
            font-style: italic;
        }
        
        .point-m {
            fill: var(--primary);
            stroke: white;
            stroke-width: 2;
            cursor: move;
            transition: r 0.2s;
        }
        
        .point-m:hover {
            r: 10;
        }
        
        .projection-line {
            stroke: var(--secondary);
            stroke-width: 1;
            stroke-dasharray: 5,3;
        }
        
        .projection-point {
            fill: var(--success);
        }
        
        .radius-line {
            stroke: var(--accent);
            stroke-width: 2;
        }
        
        .arc {
            fill: none;
            stroke: var(--accent);
            stroke-width: 1.5;
        }
        
        .coord-text {
            fill: var(--primary);
            font-size: 13px;
            font-weight: 600;
        }
        
        .angle-text {
            fill: var(--accent);
            font-size: 14px;
            font-style: italic;
            font-weight: 700;
        }
        
        .radius-text {
            fill: var(--accent);
            font-size: 13px;
            font-weight: 700;
        }
        
        .repere-label {
            fill: var(--dark-blue);
            font-size: 11px;
            font-weight: 600;
            font-style: italic;
        }
        
        .origin-label {
            fill: var(--primary);
            font-size: 15px;
            font-weight: 700;
        }
        
        .grid-dense {
            stroke: rgba(224, 224, 224, 0.3);
            stroke-width: 0.3;
        }
        
        .grid-main {
            stroke: rgba(224, 224, 224, 0.8);
            stroke-width: 0.8;
        }
        
        .thin-arrow {
            stroke-width: 1;
        }
        
        .vector-om {
            stroke: var(--accent);
            stroke-width: 2;
            marker-end: url(#very-thin-arrow);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Coordonn√©es dans le plan</h1>
        <div class="subtitle">Cart√©siennes et polaires - Vecteurs et points</div>
    </div>
    
    <div class="container">
        <div class="content-section">
            <div class="card">
                <div class="section-title">
                    <span class="icon">üìê</span>
                    Coordonn√©es cart√©siennes
                </div>
                <p>
                    Tout point $M$ du plan est rep√©r√© par un unique couple $(x;y)$ de nombres r√©els tels que 
                    $\overrightarrow{\mathrm{OM}} = x\,\vec{i} + y\,\vec{j}$.
                    $(x;y)$ est appel√© couple de <strong>coordonn√©es cart√©siennes</strong> du point $M$ dans le rep√®re 
                    $(\mathrm{O};\vec{i},\vec{j})$.
                </p>
                
                <div class="theorem">
                    <div class="theorem-title">
                        <span>üìç</span>
                        Coordonn√©es d'un vecteur
                    </div>
                    <p>
                        Dans un rep√®re cart√©sien, un vecteur $\vec{v}$ a pour coordonn√©es $(x,y)$ si :
                        $$\vec{v} = x\vec{i} + y\vec{j}$$
                        Si $A(x_A;y_A)$ et $B(x_B;y_B)$, alors :
                        $$\overrightarrow{AB} = (x_B - x_A)\vec{i} + (y_B - y_A)\vec{j}$$
                    </p>
                </div>
                
                <div class="theorem">
                    <div class="theorem-title">
                        <span>üìè</span>
                        Distance entre deux points
                    </div>
                    <div class="formula">
                        <div class="math">
                            Si $A(x_A;y_A)$ et $B(x_B;y_B)$, alors :
                            $$AB = \sqrt{(x_B - x_A)^2 + (y_B - y_A)^2}$$
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <div class="section-title">
                    <span class="icon">üéØ</span>
                    Coordonn√©es polaires
                </div>
                <p>
                    Tout point $M$ du plan distinct de $O$ est rep√©r√© par un couple $(r;\theta)$ de 
                    nombres r√©els avec $r>0$, appel√© couple de <strong>coordonn√©es polaires</strong> du 
                    point $M$, tel que $r = \mathrm{OM}$ et $\theta = (\vec{i};\overrightarrow{\mathrm{OM}})$.
                </p>
                
                <div class="angle-unit-info">
                    <strong>Unit√©s d'angle :</strong> L'angle $\theta$ peut √™tre exprim√© en degr√©s ($¬∞$) ou en radians (rad).
                    $$1 \text{ rad} = \frac{180}{\pi}¬∞ \approx 57.3¬∞$$
                    $$180¬∞ = \pi \text{ rad}$$
                    Sur la figure interactive, $\theta$ est affich√© en degr√©s, mais les formules fonctionnent avec les deux unit√©s.
                </div>
                
                <div class="theorem">
                    <div class="theorem-title">
                        <span>üî¢</span>
                        Coordonn√©es polaires d'un vecteur
                    </div>
                    <p>
                        Un vecteur $\vec{v}$ peut √©galement √™tre repr√©sent√© en coordonn√©es polaires $(r,\theta)$ o√π :
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li>$r = \|\vec{v}\|$ est la norme du vecteur</li>
                            <li>$\theta$ est l'angle que fait le vecteur avec l'axe des abscisses (en degr√©s ou radians)</li>
                        </ul>
                        On a alors : $\vec{v} = (r\cos\theta, r\sin\theta)$ en coordonn√©es cart√©siennes.
                    </p>
                </div>
            </div>
            
            <div class="card">
                <div class="section-title">
                    <span class="icon">üîÑ</span>
                    Relations de passage
                </div>
                <p>
                    Si un point $M$ distinct de $O$ a pour coordonn√©es cart√©siennes $(x;y)$ et pour 
                    coordonn√©es polaires $(r;\theta)$, alors :
                </p>
                
                <div class="formula">
                    <div class="math">
                        <strong>Cart√©siennes ‚Üí Polaires</strong><br>
                        $$r = \sqrt{x^2 + y^2}$$
                        $$\theta = \arctan\left(\frac{y}{x}\right) \quad (\text{avec ajustement de quadrant})$$
                    </div>
                </div>
                
                <div class="formula">
                    <div class="math">
                        <strong>Polaires ‚Üí Cart√©siennes</strong><br>
                        $$x = r\cos\theta$$
                        $$y = r\sin\theta$$
                        <em>Note : $\theta$ peut √™tre en degr√©s ou radians selon le contexte.</em>
                    </div>
                </div>
                
                
        <div class="visualization-section">
            <div class="visualization-container">
                <div class="visualization-title">Repr√©sentation interactive</div>
                
                <div id="svg-container"></div>
                
                <div class="coordinate-display">
                    <div class="coord-group">
                        <div class="coord-label">Point M cart√©sien</div>
                        <div class="coord-value" id="cartesian-coords">(0.00, 0.00)</div>
                    </div>
                    <div class="coord-group">
                        <div class="coord-label">Point M polaire</div>
                        <div class="coord-value" id="polar-coords">(0.00, 0.00¬∞)</div>
                    </div>
                    <div class="coord-group">
                        <div class="coord-label">Vecteur $\vec{OM}$</div>
                        <div class="coord-value" id="vector-coords">(0.00, 0.00)</div>
                    </div>
                </div>
                
                <div class="instructions">
                    <i>üí° D√©placer le point M directement sur le graphique</i>
                </div>
                
                <div class="video-section">
                    <div class="video-title">üé• Vid√©o explicative</div>
                    <p>Pour voir la m√©thode de conversion sur calculatrice Casio fx-92 en vid√©o :</p>
                    <a href="https://www.youtube.com/watch?v=iKV5fWz1w8g" target="_blank" class="video-link">
                        <span>‚ñ∂Ô∏è</span>
                        Voir la vid√©o sur YouTube
                    </a>
                    <p style="margin-top: 10px; font-size: 0.9em; color: #666;">
                        Tutoriel Casio fx-92 : Conversion coordonn√©es polaires/cart√©siennes
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let svg, svgSize, centerX, centerY;
        let r = 120, thetaDeg = 40;
        
        // Initialisation du SVG
        function initSVG() {
            const container = document.getElementById('svg-container');
            svgSize = {
                width: container.clientWidth,
                height: container.clientHeight
            };
            
            centerX = svgSize.width / 2;
            centerY = svgSize.height / 2;
            
            // Cr√©er ou mettre √† jour le SVG
            if (!svg) {
                svg = d3.select("#svg-container")
                    .append("svg")
                    .attr("width", svgSize.width)
                    .attr("height", svgSize.height);
            } else {
                svg.attr("width", svgSize.width)
                   .attr("height", svgSize.height);
            }
            
            // Nettoyer le SVG
            svg.selectAll("*").remove();
            
            // Cr√©er les marqueurs de fl√®ches fines
            const defs = svg.append("defs");
            
            // Fl√®che fine pour les axes
            defs.append("marker")
                .attr("id", "thin-arrow")
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("refX", 5)
                .attr("refY", 3)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,0 L0,6 L6,3 Z")
                .attr("fill", "#0d47a1");
            
            // Fl√®che tr√®s fine pour les vecteurs
            defs.append("marker")
                .attr("id", "very-thin-arrow")
                .attr("markerWidth", 4)
                .attr("markerHeight", 4)
                .attr("refX", 3.5)
                .attr("refY", 2)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,0 L0,4 L4,2 Z")
                .attr("fill", "#0277bd");
            
            // Dessiner le quadrillage
            drawGrid();
            
            // Dessiner le rep√®re
            drawRepere();
            
            // Initialiser les √©l√©ments interactifs
            initInteractiveElements();
            
            // Mettre √† jour la visualisation
            updateVisualization();
        }
        
        // Dessiner le quadrillage
        function drawGrid() {
            const gridSize = 20; // Espacement entre les lignes
            const gridGroup = svg.append("g").attr("class", "grid");
            
            // Calculer le nombre de lignes n√©cessaires
            const xLines = Math.ceil(svgSize.width / gridSize);
            const yLines = Math.ceil(svgSize.height / gridSize);
            
            // Lignes verticales (fines)
            for (let i = -xLines; i <= xLines; i++) {
                const x = centerX + i * gridSize;
                gridGroup.append("line")
                    .attr("x1", x).attr("y1", 0)
                    .attr("x2", x).attr("y2", svgSize.height)
                    .attr("class", "grid-dense");
            }
            
            // Lignes horizontales (fines)
            for (let i = -yLines; i <= yLines; i++) {
                const y = centerY + i * gridSize;
                gridGroup.append("line")
                    .attr("x1", 0).attr("y1", y)
                    .attr("x2", svgSize.width).attr("y2", y)
                    .attr("class", "grid-dense");
            }
            
            // Lignes principales (tous les 5 carreaux)
            const mainGridSize = gridSize * 5;
            const mainXLines = Math.ceil(svgSize.width / mainGridSize);
            const mainYLines = Math.ceil(svgSize.height / mainGridSize);
            
            // Lignes verticales principales
            for (let i = -mainXLines; i <= mainXLines; i++) {
                const x = centerX + i * mainGridSize;
                gridGroup.append("line")
                    .attr("x1", x).attr("y1", 0)
                    .attr("x2", x).attr("y2", svgSize.height)
                    .attr("class", "grid-main");
                
                // Graduations sur l'axe x
                if (i !== 0) {
                    gridGroup.append("text")
                        .attr("x", x)
                        .attr("y", centerY + 15)
                        .attr("text-anchor", "middle")
                        .attr("class", "repere-label")
                        .text(i * 5);
                }
            }
            
            // Lignes horizontales principales
            for (let i = -mainYLines; i <= mainYLines; i++) {
                const y = centerY + i * mainGridSize;
                gridGroup.append("line")
                    .attr("x1", 0).attr("y1", y)
                    .attr("x2", svgSize.width).attr("y2", y)
                    .attr("class", "grid-main");
                
                // Graduations sur l'axe y (sauf pour y=0)
                if (i !== 0) {
                    gridGroup.append("text")
                        .attr("x", centerX - 12)
                        .attr("y", y + 4)
                        .attr("text-anchor", "end")
                        .attr("class", "repere-label")
                        .text(-i * 5);
                }
            }
        }
        
        // Dessiner le rep√®re
        function drawRepere() {
            // Axe des x avec fl√®che fine
            svg.append("line")
                .attr("x1", 20).attr("y1", centerY)
                .attr("x2", svgSize.width - 20).attr("y2", centerY)
                .attr("class", "axis thin-arrow")
                .attr("marker-end", "url(#thin-arrow)");
            
            // Axe des y avec fl√®che fine
            svg.append("line")
                .attr("x1", centerX).attr("y1", svgSize.height - 20)
                .attr("x2", centerX).attr("y2", 20)
                .attr("class", "axis thin-arrow")
                .attr("marker-end", "url(#thin-arrow)");
            
            // Labels des axes
            svg.append("text")
                .attr("x", svgSize.width - 20)
                .attr("y", centerY - 8)
                .attr("class", "axis-label")
                .text("x");
            
            svg.append("text")
                .attr("x", centerX + 12)
                .attr("y", 25)
                .attr("class", "axis-label")
                .text("y");
            
            // Origine O
            svg.append("circle")
                .attr("cx", centerX)
                .attr("cy", centerY)
                .attr("r", 2)
                .attr("fill", "#0a2463");
            
            svg.append("text")
                .attr("x", centerX - 12)
                .attr("y", centerY + 20)
                .attr("class", "origin-label")
                .text("O");
            
            // Vecteur i avec fl√®che tr√®s fine
            svg.append("line")
                .attr("x1", centerX).attr("y1", centerY)
                .attr("x2", centerX + 50).attr("y2", centerY)
                .attr("class", "vector")
                .attr("marker-end", "url(#very-thin-arrow)");
            
            svg.append("text")
                .attr("x", centerX + 52)
                .attr("y", centerY + 3)
                .attr("class", "vector-label")
                .text("i");
            
            // Vecteur j avec fl√®che tr√®s fine
            svg.append("line")
                .attr("x1", centerX).attr("y1", centerY)
                .attr("x2", centerX).attr("y2", centerY - 50)
                .attr("class", "vector")
                .attr("marker-end", "url(#very-thin-arrow)");
            
            svg.append("text")
                .attr("x", centerX - 3)
                .attr("y", centerY - 52)
                .attr("class", "vector-label")
                .text("j");
            
            // Label du rep√®re
            svg.append("text")
                .attr("x", centerX - 35)
                .attr("y", centerY - 70)
                .attr("class", "repere-label")
                .text("(O; i, j)");
        }
        
        // Initialiser les √©l√©ments interactifs
        function initInteractiveElements() {
            // Cr√©er les groupes pour une meilleure organisation
            const projectionsGroup = svg.append("g").attr("class", "projections");
            const polarGroup = svg.append("g").attr("class", "polar");
            const pointGroup = svg.append("g").attr("class", "point");
            const vectorGroup = svg.append("g").attr("class", "vectors");
            
            // Lignes de projection
            projectionsGroup.append("line").attr("class", "projection-line");
            projectionsGroup.append("line").attr("class", "projection-line");
            
            // Points de projection
            projectionsGroup.append("circle").attr("class", "projection-point").attr("r", 3);
            projectionsGroup.append("circle").attr("class", "projection-point").attr("r", 3);
            
            // Labels des coordonn√©es
            projectionsGroup.append("text").attr("class", "coord-text");
            projectionsGroup.append("text").attr("class", "coord-text");
            
            // √âl√©ments polaires
            polarGroup.append("path").attr("class", "arc");
            polarGroup.append("line").attr("class", "radius-line");
            polarGroup.append("text").attr("class", "radius-text");
            polarGroup.append("text").attr("class", "angle-text");
            
            // Vecteur OM avec fl√®che tr√®s fine (sans √©tiquette)
            vectorGroup.append("line")
                .attr("class", "vector-om")
                .attr("stroke-width", 2);
            
            // Point M et son label
            pointGroup.append("circle")
                .attr("class", "point-m")
                .attr("r", 6)
                .call(d3.drag()
                    .on("start", dragStarted)
                    .on("drag", dragged)
                    .on("end", dragEnded));
            
            pointGroup.append("text")
                .attr("class", "axis-label")
                .attr("font-size", "16");
        }
        
        // Fonctions de drag am√©lior√©es
        function dragStarted(event) {
            d3.select(this).raise().classed("active", true);
        }
        
        function dragged(event) {
            const mouseX = event.x;
            const mouseY = event.y;
            
            // Limites pour garder le point visible
            const boundedX = Math.max(20, Math.min(svgSize.width - 20, mouseX));
            const boundedY = Math.max(20, Math.min(svgSize.height - 20, mouseY));
            
            const relX = boundedX - centerX;
            const relY = centerY - boundedY; // Invers√© car y cro√Æt vers le bas en SVG
            
            r = Math.sqrt(relX * relX + relY * relY);
            let theta = Math.atan2(relY, relX) * 180 / Math.PI;
            
            if (theta < 0) theta += 360;
            
            // Limites
            r = Math.max(10, Math.min(180, r));
            thetaDeg = Math.round(theta * 10) / 10; // Arrondir au dixi√®me
            
            updateVisualization();
        }
        
        function dragEnded(event) {
            d3.select(this).classed("active", false);
        }
        
        // Mettre √† jour la visualisation
        function updateVisualization() {
            const thetaRad = thetaDeg * Math.PI / 180;
            const x = r * Math.cos(thetaRad);
            const y = r * Math.sin(thetaRad);
            
            const pointX = centerX + x;
            const pointY = centerY - y; // Invers√© car y cro√Æt vers le bas en SVG
            
            // Point M
            svg.select(".point-m")
                .attr("cx", pointX)
                .attr("cy", pointY);
            
            svg.select(".point-m + text")
                .attr("x", pointX + 12)
                .attr("y", pointY - 12)
                .text("M");
            
            // Vecteur OM (sans √©tiquette comme demand√©)
            svg.select(".vector-om")
                .attr("x1", centerX).attr("y1", centerY)
                .attr("x2", pointX).attr("y2", pointY);
            
            // Rayon OM (ligne sans fl√®che pour le rayon polaire)
            svg.select(".radius-line")
                .attr("x1", centerX).attr("y1", centerY)
                .attr("x2", pointX).attr("y2", pointY);
            
            // Label du rayon
            const midX = centerX + x * 0.4;
            const midY = centerY - y * 0.4;
            svg.select(".radius-text")
                .attr("x", midX - 15)
                .attr("y", midY - 8)
                .text(`r = ${r.toFixed(1)}`);
            
            // Arc d'angle
            const arcRadius = Math.min(45, r * 0.25);
            const largeArcFlag = Math.abs(thetaDeg) > 180 ? 1 : 0;
            const sweepFlag = thetaDeg >= 0 ? 0 : 1;
            
            const endX = centerX + arcRadius * Math.cos(thetaRad);
            const endY = centerY - arcRadius * Math.sin(thetaRad);
            
            const arcPathData = [
                `M ${centerX + arcRadius} ${centerY}`,
                `A ${arcRadius} ${arcRadius} 0 ${largeArcFlag} ${sweepFlag} ${endX} ${endY}`
            ].join(' ');
            
            svg.select(".arc").attr("d", arcPathData);
            
            // Label de l'angle
            const labelAngle = thetaDeg / 2;
            const labelRad = labelAngle * Math.PI / 180;
            const labelDistance = arcRadius + 15;
            svg.select(".angle-text")
                .attr("x", centerX + labelDistance * Math.cos(labelRad))
                .attr("y", centerY - labelDistance * Math.sin(labelRad) + 5)
                .text(`Œ∏ = ${thetaDeg.toFixed(1)}¬∞`);
            
            // Projections sur les axes
            const projections = svg.selectAll(".projection-line");
            projections.nodes()[0].setAttribute("x1", pointX);
            projections.nodes()[0].setAttribute("y1", pointY);
            projections.nodes()[0].setAttribute("x2", pointX);
            projections.nodes()[0].setAttribute("y2", centerY);
            
            projections.nodes()[1].setAttribute("x1", pointX);
            projections.nodes()[1].setAttribute("y1", pointY);
            projections.nodes()[1].setAttribute("x2", centerX);
            projections.nodes()[1].setAttribute("y2", pointY);
            
            // Points de projection
            const projPoints = svg.selectAll(".projection-point");
            projPoints.nodes()[0].setAttribute("cx", pointX);
            projPoints.nodes()[0].setAttribute("cy", centerY);
            projPoints.nodes()[1].setAttribute("cx", centerX);
            projPoints.nodes()[1].setAttribute("cy", pointY);
            
            // Labels des coordonn√©es
            const coordTexts = svg.selectAll(".coord-text");
            coordTexts.nodes()[0].setAttribute("x", pointX - 20);
            coordTexts.nodes()[0].setAttribute("y", centerY + 20);
            coordTexts.nodes()[0].textContent = `x = ${x.toFixed(1)}`;
            
            coordTexts.nodes()[1].setAttribute("x", centerX + 12);
            coordTexts.nodes()[1].setAttribute("y", pointY - 8);
            coordTexts.nodes()[1].textContent = `y = ${y.toFixed(1)}`;
            
            // Calculer aussi en radians pour l'affichage optionnel
            const thetaRadValue = thetaDeg * Math.PI / 180;
            
            // Mise √† jour des affichages
            document.getElementById('cartesian-coords').textContent = `(${x.toFixed(2)}, ${y.toFixed(2)})`;
            document.getElementById('polar-coords').textContent = `(${r.toFixed(2)}, ${thetaDeg.toFixed(1)}¬∞)`;
            document.getElementById('vector-coords').textContent = `(${x.toFixed(2)}, ${y.toFixed(2)})`;
        }
        
        // Initialisation
        function init() {
            initSVG();
            updateVisualization();
        }
        
        // Redimensionnement
        window.addEventListener('resize', init);
        
        // Initialiser quand la page est charg√©e
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
